{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useState, useEffect, useRef } from \"react\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport { createNavigationContainerRef } from \"@react-navigation/native\";\nexport var RootNavigation = {\n  navigate: function navigate(_name, _params) {},\n  goBack: function goBack() {},\n  resetRoot: function resetRoot(_state) {},\n  getRootState: function getRootState() {\n    return {};\n  },\n  dispatch: function dispatch(_action) {}\n};\nexport var navigationRef = createNavigationContainerRef();\nexport function getActiveRouteName(state) {\n  var route = state.routes[state.index];\n  if (!route.state) return route.name;\n  return getActiveRouteName(route.state);\n}\nexport function useBackButtonHandler(canExit) {\n  var canExitRef = useRef(canExit);\n  useEffect(function () {\n    canExitRef.current = canExit;\n  }, [canExit]);\n  useEffect(function () {\n    var onBackPress = function onBackPress() {\n      if (!navigationRef.isReady()) {\n        return false;\n      }\n      var routeName = getActiveRouteName(navigationRef.getRootState());\n      if (canExitRef.current(routeName)) {\n        BackHandler.exitApp();\n        return true;\n      }\n      if (navigationRef.canGoBack()) {\n        navigationRef.goBack();\n        return true;\n      }\n      return false;\n    };\n    BackHandler.addEventListener(\"hardwareBackPress\", onBackPress);\n    return function () {\n      return BackHandler.removeEventListener(\"hardwareBackPress\", onBackPress);\n    };\n  }, []);\n}\nexport function useNavigationPersistence(storage, persistenceKey) {\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    initialNavigationState = _useState2[0],\n    setInitialNavigationState = _useState2[1];\n  var _useState3 = useState(!__DEV__),\n    _useState4 = _slicedToArray(_useState3, 2),\n    isRestored = _useState4[0],\n    setIsRestored = _useState4[1];\n  var routeNameRef = useRef();\n  var onNavigationStateChange = function onNavigationStateChange(state) {\n    var previousRouteName = routeNameRef.current;\n    var currentRouteName = getActiveRouteName(state);\n    if (previousRouteName !== currentRouteName) {\n      __DEV__ && console.tron.log(currentRouteName);\n    }\n    routeNameRef.current = currentRouteName;\n    storage.save(persistenceKey, state);\n  };\n  var restoreState = function () {\n    var _ref = _asyncToGenerator(function* () {\n      try {\n        var state = yield storage.load(persistenceKey);\n        if (state) setInitialNavigationState(state);\n      } finally {\n        setIsRestored(true);\n      }\n    });\n    return function restoreState() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  useEffect(function () {\n    if (!isRestored) restoreState();\n  }, [isRestored]);\n  return {\n    onNavigationStateChange: onNavigationStateChange,\n    restoreState: restoreState,\n    isRestored: isRestored,\n    initialNavigationState: initialNavigationState\n  };\n}\nexport function navigate(name, params) {\n  if (navigationRef.isReady()) {\n    navigationRef.navigate(name, params);\n  }\n}\nexport function goBack() {\n  if (navigationRef.isReady() && navigationRef.canGoBack()) {\n    navigationRef.goBack();\n  }\n}\nexport function resetRoot() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    index: 0,\n    routes: []\n  };\n  if (navigationRef.isReady()) {\n    navigationRef.resetRoot(params);\n  }\n}","map":{"version":3,"names":["useState","useEffect","useRef","createNavigationContainerRef","RootNavigation","navigate","_name","_params","goBack","resetRoot","_state","getRootState","dispatch","_action","navigationRef","getActiveRouteName","state","route","routes","index","name","useBackButtonHandler","canExit","canExitRef","current","onBackPress","isReady","routeName","BackHandler","exitApp","canGoBack","addEventListener","removeEventListener","useNavigationPersistence","storage","persistenceKey","initialNavigationState","setInitialNavigationState","__DEV__","isRestored","setIsRestored","routeNameRef","onNavigationStateChange","previousRouteName","currentRouteName","console","tron","log","save","restoreState","load","params"],"sources":["/Users/jamesgalante/Desktop/Splitsy/app/navigators/navigation-utilities.tsx"],"sourcesContent":["import { useState, useEffect, useRef } from \"react\"\nimport { BackHandler } from \"react-native\"\nimport {\n  PartialState,\n  NavigationState,\n  NavigationAction,\n  createNavigationContainerRef,\n} from \"@react-navigation/native\"\n\n/* eslint-disable */\nexport const RootNavigation = {\n  navigate(_name: string, _params?: any) {},\n  goBack() {},\n  resetRoot(_state?: PartialState<NavigationState> | NavigationState) {},\n  getRootState(): NavigationState {\n    return {} as any\n  },\n  dispatch(_action: NavigationAction) {},\n}\n/* eslint-enable */\n\nexport const navigationRef = createNavigationContainerRef()\n\n/**\n * Gets the current screen from any navigation state.\n */\nexport function getActiveRouteName(state: NavigationState | PartialState<NavigationState>) {\n  const route = state.routes[state.index]\n\n  // Found the active route -- return the name\n  if (!route.state) return route.name\n\n  // Recursive call to deal with nested routers\n  return getActiveRouteName(route.state)\n}\n\n/**\n * Hook that handles Android back button presses and forwards those on to\n * the navigation or allows exiting the app.\n */\nexport function useBackButtonHandler(canExit: (routeName: string) => boolean) {\n  const canExitRef = useRef(canExit)\n\n  useEffect(() => {\n    canExitRef.current = canExit\n  }, [canExit])\n\n  useEffect(() => {\n    // We'll fire this when the back button is pressed on Android.\n    const onBackPress = () => {\n      if (!navigationRef.isReady()) {\n        return false\n      }\n\n      // grab the current route\n      const routeName = getActiveRouteName(navigationRef.getRootState())\n\n      // are we allowed to exit?\n      if (canExitRef.current(routeName)) {\n        // exit and let the system know we've handled the event\n        BackHandler.exitApp()\n        return true\n      }\n\n      // we can't exit, so let's turn this into a back action\n      if (navigationRef.canGoBack()) {\n        navigationRef.goBack()\n        return true\n      }\n\n      return false\n    }\n\n    // Subscribe when we come to life\n    BackHandler.addEventListener(\"hardwareBackPress\", onBackPress)\n\n    // Unsubscribe when we're done\n    return () => BackHandler.removeEventListener(\"hardwareBackPress\", onBackPress)\n  }, [])\n}\n\n/**\n * Custom hook for persisting navigation state.\n */\nexport function useNavigationPersistence(storage: any, persistenceKey: string) {\n  const [initialNavigationState, setInitialNavigationState] = useState()\n\n  // This feature is particularly useful in development mode.\n  // It is selectively enabled in development mode with\n  // the following approach. If you'd like to use navigation persistence\n  // in production, remove the __DEV__ and set the state to false\n  const [isRestored, setIsRestored] = useState(!__DEV__)\n\n  const routeNameRef = useRef<string | undefined>()\n\n  const onNavigationStateChange = (state) => {\n    const previousRouteName = routeNameRef.current\n    const currentRouteName = getActiveRouteName(state)\n\n    if (previousRouteName !== currentRouteName) {\n      // track screens.\n      __DEV__ && console.tron.log(currentRouteName)\n    }\n\n    // Save the current route name for later comparision\n    routeNameRef.current = currentRouteName\n\n    // Persist state to storage\n    storage.save(persistenceKey, state)\n  }\n\n  const restoreState = async () => {\n    try {\n      const state = await storage.load(persistenceKey)\n      if (state) setInitialNavigationState(state)\n    } finally {\n      setIsRestored(true)\n    }\n  }\n\n  useEffect(() => {\n    if (!isRestored) restoreState()\n  }, [isRestored])\n\n  return { onNavigationStateChange, restoreState, isRestored, initialNavigationState }\n}\n\n/**\n * use this to navigate without the navigation\n * prop. If you have access to the navigation prop, do not use this.\n * More info: https://reactnavigation.org/docs/navigating-without-navigation-prop/\n */\nexport function navigate(name: any, params?: any) {\n  if (navigationRef.isReady()) {\n    navigationRef.navigate(name as never, params as never)\n  }\n}\n\nexport function goBack() {\n  if (navigationRef.isReady() && navigationRef.canGoBack()) {\n    navigationRef.goBack()\n  }\n}\n\nexport function resetRoot(params = { index: 0, routes: [] }) {\n  if (navigationRef.isReady()) {\n    navigationRef.resetRoot(params)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}